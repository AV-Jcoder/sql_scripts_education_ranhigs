 
 /**
  * Процедуры были введены в PostgreSQL 11. Основная причина их 
появления состоит в том, что функции не могут управлять 
транзакциями. Функции вызываются в контексте какого-либо 
выражения, которое вычисляется как часть уже начатого оператора 
(например SELECT) в уже начатой транзакции. Нельзя завершить 
транзакцию и начать новую «посередине» выполнения оператора.
Процедуры всегда вызываются специальным оператором CALL. Если 
этот оператор сам начинает новую транзакцию (а не вызывается из уже 
начатой), то в процедуре можно использовать команды управления 
транзакциями.
К сожалению, процедуры, написанные на языке SQL, лишены 
возможности использовать команды COMMIT и ROLLBACK. Поэтому 
пример процедуры, управляющей транзакциями, придется отложить до 
темы «PL/pgSQL. Выполнение запросов».
Иногда можно услышать, что процедура отличается от функции тем, 
что не возвращает результат. Но это не так — процедуры тоже могут 
возвращать результат, если необходимо.
Вместе функции и процедуры называются подпрограммами (routine). 
  * 
  * 
  */

/**
 * Процедуры без параметров
 * 
 */

CREATE TABLE tab1(num float4);

CREATE PROCEDURE fill()
AS $$
	TRUNCATE tab1;
	INSERT INTO tab1 SELECT random() FROM generate_series(1,3);
$$ LANGUAGE SQL;

/**
 * чтобы вызвать процедуру, необходимо 
 * использовать специальныйы оператор CALL
 */

CALL fill();

SELECT * FROM tab1;

/**
 * Тот же эффект можно получить и с помощью функции. 
 * Функция на языке SQL тоже может состоять из нескольких 
 * операторов (не обязательно SELECT); возвращаемое значение
 * определяется последним оператором. Можно объявить тип результата void, 
 * если фактически функция ничего не возвращает, 
 * или вернуть что-то осмысленное: 
 * 
 */

CREATE FUNCTION fill_avg() 
RETURNS float
AS $$
	TRUNCATE tab1;
	INSERT INTO tab1 SELECT random() FROM generate_series(1,3);
	SELECT avg(num) FROM tab1;
$$ LANGUAGE SQL;

SELECT fill_avg();
SELECT * FROM tab1;

/**
 * Чего нельзя достичь с помощью функции — 
 * это управления транзакциями. 
 * Но и в процедурах на языке SQL это не поддерживается
 * (зато поддерживается при использовании других языков). 
 */


/**
 * Процедуры с параметрами 
 */
 
/**
 * Добавим в процедуру входной параметр — число строк: 
 */
 
DROP PROCEDURE fill();

CREATE PROCEDURE  fill(nrows int)
AS $$
	TRUNCATE tab1;
	INSERT INTO tab1 SELECT random() FROM generate_series(1,nrows);
	SELECT 'Hello';
$$ LANGUAGE SQL;

/**
 * Точно так же, как и в случае функций, 
 * при вызове процедур фактические параметры 
 * можно передавать позиционным способом или по имени: 
 */

CALL fill(nrows => 4);

SELECT * FROM tab1;

/**
 * 
 * Процедуры могут также иметь INOUT-параметры, 
 * позволяющие возвращать значение. 
 * OUT-параметры пока не поддерживаются (но будут в PostgreSQL 14). * 
 */

DROP PROCEDURE fill(int);


CREATE PROCEDURE fill(IN nrows int, INOUT average float)
AS $$
	TRUNCATE tab1;
	INSERT INTO tab1 SELECT random() FROM generate_series(1, nrows);
	SELECT avg(num) FROM tab1;
$$ LANGUAGE SQL;

/**
 * Точно так же, как и в случае функций,
 * при вызове процедур фактические параметры
 * можно передавать позиционным способом или по имени: 
 */

CALL fill(5, null); -- второе входное значение не используется.



/**
 * 
Перегрузка
Несколько подпрограмм с одним и тем же именем
подпрограммы различаются типами входных параметров;
fill(int)
fill(text)
тип возвращаемого значения и выходные параметры игнорируются
подходящая подпрограмма выбирается во время выполнения
в зависимости от фактических параметров
Команда CREATE OR REPLACE
при несовпадении типов входных параметров создаст новую
перегруженную подпрограмму
при совпадении — изменит существующую подпрограмму,
но поменять тип возвращаемого значения нельзя
 *
 */

CREATE FUNCTION fill(int, text)
RETURNS void
AS $$	
$$ LANGUAGE SQL;

/**
 * 
 */

CREATE FUNCTION fill(TEXT, int)
RETURNS void
AS $$	
$$ LANGUAGE SQL;

CREATE FUNCTION fill(TEXT, int)
RETURNS TEXT
AS $$	
	SELECT 'hello';
$$ LANGUAGE SQL;

DROP function fill(TEXT,int);


/** 
 * Перегрузка — это возможность использования одного и того же имени 
для нескольких подпрограмм (функций или процедур), отличающихся 
типами параметров IN и INOUT. Иными словами, сигнатура 
подпрограммы — ее имя и типы входных параметров.
При вызове подпрограммы PostgreSQL находит ту подпрограмму, 
которая соответствует переданным фактическим параметрам. 
Возможны ситуации, когда подходящую подпрограмму невозможно 
определить однозначно; в таком случае во время выполнения 
возникнет ошибка.
Перегрузку надо учитывать при использовании команды CREATE OR 
REPLACE (FUNCTION или PROCEDURE). Дело в том, что при 
несовпадении типов входных параметров будет создана новая — 
перегруженная — подпрограмма. Кроме того, для функций эта команда 
не позволяет изменить тип возвращаемого значения и типы выходных 
параметров.
Поэтому при необходимости следует удалять подпрограмму и 
создавать ее заново, но это будет уже новая подпрограмма. При 
удалении старой функции потребуется также удалить зависящие от нее 
представления, триггеры и т. п. (DROP FUNCTION ... CASCADE). 
 */



/**
 * Полиморфизм
Подпрограмма, принимающая параметры разных типов
формальные параметры используют полиморфные псевдотипы
(например, anyelement)
конкретный тип данных выбирается во время выполнения
по типу фактических параметров
 */

/**
 * В некоторых случаях удобно не создавать несколько перегруженных 
подпрограмм для разных типов, а написать одну, принимающую 
параметры любого (или почти любого) типа.
Для этого в качестве типа формального параметра указывается 
специальный полиморфный псевдотип. Пока мы ограничимся одним 
типом — anyelement, который соответствует любому базовому типу, — 
но позже познакомимся и с другими.
Конкретный тип, с которым будет работать подпрограмма, выбирается 
во время выполнения по типу фактического параметра.
Если у подпрограммы определено несколько полиморфных 
параметров, то типы соответствующих фактических параметров 
должны совпадать. Иными словами, anyelement при каждом вызове 
функции обозначает какой-то один конкретный тип.
Если функция объявлена с возвращаемым значением полиморфного  
типа, то она должна иметь по крайней мере один входной 
полиморфный параметр. Конкретный тип возвращаемого значения 
также определяется исходя из типа фактического входного параметра.
 */



/**
 * 
 *  Перегруженные подпрограммы
Перегрузка работает одинаково и для функций, и для процедур. 
Они имеют общее пространство имен.
В качестве примера напишем функцию, возвращающую большее из двух целых чисел.
(Похожее выражение есть в SQL и называется greatest, но мы напишем собственную функцию.)
 *  
 */
 
CREATE FUNCTION maximum(a int,b int) 
RETURNS integer AS 
$$
SELECT
CASE 
	WHEN a > b THEN a
	ELSE b
END;
$$ LANGUAGE SQL;

SELECT maximum(10,20);

/**
 * Допустим, мы решили сделать аналогичную функцию для трех чисел.
 * Благодаря перегрузке, не надо придумывать для нее какое-то новое название:
 */

CREATE FUNCTION maximum(a int,b int, c int) 
RETURNS integer AS 
$$
SELECT
CASE 
	WHEN a > b THEN greatest(a,c)
	ELSE maximum(b,c)
END;
$$ LANGUAGE SQL;

SELECT maximum(10,20,30);

/**
 * Теперь у нас две функции с одним именем, но разным числом параметров: 
 */
 
SELECT maximum(10,20), maximum(10,20,30);


/**
 * Команда CREATE OR REPLACE позволяет создать подпрограмму 
 * или заменить существующую, не удаляя ее. 
 * Поскольку в данном случае функция с такой 
 * сигнатурой уже существует, она будет заменена: 
 */


CREATE OR REPLACE FUNCTION maximum(a int,b int, c int) 
RETURNS integer AS 
$$
SELECT
CASE 
	WHEN a > b THEN
				CASE 
					WHEN a > c THEN a ELSE c	
				END
	WHEN a < b THEN 
				CASE 
					WHEN b > c THEN b ELSE c	
				END
END;
$$ LANGUAGE SQL;

SELECT maximum(10,20,30);


/**
 * Пусть наша функция работает не только для целых чисел, но и для вещественных.
 * Как этого добиться? Можно было бы определить еще такую функцию: 
 */


CREATE FUNCTION maximum(a real,b real) 
RETURNS real AS 
$$
SELECT
	CASE 
		WHEN a > b THEN a 
		ELSE b
	END;
$$ LANGUAGE SQL;

SELECT maximum(1.1,2.5);

/**
 * 
 * Две из них имеют одинаковое количество параметров, 
 * но отличаются их типами:
 * 
 */

SELECT maximum(10, 20), maximum(1.1, 2.2);

/********/

CREATE FUNCTION maximum(a real,b REAL, c real) 
RETURNS real AS 
$$
SELECT
	CASE 
		WHEN a > b AND a > c THEN a
		WHEN b > a AND b > c THEN b
		ELSE c
	END;
$$ LANGUAGE SQL;

SELECT maximum(1.1,2.5,3.0);

/**
 * Но дальше нам придется определить функции и для всех остальных типов данных, 
 * при том, что тело функции не меняется. И затем придется повторить 
 * все то же самое для варианта с тремя параметрами. 
 */


/**
 *  Полиморфные функции
 * 
 * Здесь нам поможет полиморфный тип anyelement.
 * 
 */

DROP FUNCTION maximum(real, REAL, real); 
DROP FUNCTION maximum(real, real);
DROP FUNCTION maximum(int, int, int) ;
DROP FUNCTION maximum(int, int);

--...и затем создадим новую: 


CREATE FUNCTION maximum(a anyelement, b anyelement)
RETURNS anyelement 
AS $$
	SELECT 
		CASE 
			WHEN a > b THEN a 
			ELSE b
		END;
$$ LANGUAGE SQL;


SELECT maximum('a','b');


/**
 * ERROR:  could not determine polymorphic type because input has type unknown
 * Увы, нет. В данном случае строковые литералы могут быть типа char, varchar, text — 
 * конкретный тип нам неизвестен. Но можно применить явное приведение типов:  
 */

SELECT maximum('a'::text,'b'::text);


/**
 * Еще пример с другим типом: 
 */

SELECT maximum(now(), now() + interval '1 day');


/**
 * Тип результата функции всегда будет тот же, что и тип параметров.
 * Важно, чтобы типы обоих параметров совпадали, иначе будет ошибка: 
 * 
 */

SELECT maximum(1,'A');

/**
 * ERROR:  invalid input syntax for type integer: "A"
 * LINE 1: SELECT maximum(1, 'A');
 * В этом примере такое ограничение выглядит естественно, 
 * хотя в некоторых случаях оно может оказаться и неудобным. 
 *  
 */
-------------------------------------------------------------

/**
 * Определим теперь функцию с тремя параметрами, 
 * но так, чтобы третий можно было не указывать. 
 */
DROP FUNCTION maximum(anyelement, anyelement, anyelement); 

CREATE FUNCTION maximum (a anyelement, b anyelement, c anyelement DEFAULT null)
RETURNS anyelement 
AS $$
SELECT CASE
        	WHEN c IS NULL THEN HI
        	ELSE
          	CASE 
	          	WHEN HI > c THEN HI
	          	ELSE c END
	          END
FROM (
    SELECT CASE WHEN 1 > 2 THEN 1 ELSE 2 END
) max2(HI);
$$ LANGUAGE SQL;

SELECT maximum(1,2,3);

--Так работает. А так?

SELECT maximum(1,2);

-- А так произошел конфликт перегруженных функций: 

/**
 * Невозможно понять, имеем ли мы в виду функцию с двумя параметрами, 
 * или с тремя (но просто не указали последний).
 * Мы решим этот конфликт просто — 
 * удалим первую функцию за ненадобностью.
 *  
 */

DROP FUNCTION maximum(anyelement, anyelement); 

SELECT maximum(1,2), maximum(1,2,3);

/**
 * Теперь все работает. А в теме «PL/pgSQL. Массивы» мы узнаем, 
 * как определять подпрограммы с произвольным числом параметров. 
 */

   
/**
 * Итоги
 * Можно создавать и использовать собственные процедуры
 * В отличие от функций, процедуры вызываются оператором
 * CALL и могут управлять транзакциями
 * Для процедур и функций поддерживаются перегрузка
 * и полиморфизм 
 */



/**
 * 10
 * Практика
 * 1. Получится ли создать в одной и той же схеме и имеющие
 * одно и то же имя: 1) процедуру с одним входным параметром,
 * 2) функцию с одним входным параметром того же типа,
 * возвращающую некоторое значение? Проверьте
 *  
 */
DROP FUNCTION example(int)

CREATE FUNCTION example(int)
RETURNS int 
AS $$
	SELECT $1;
$$ LANGUAGE sql;

SELECT example(2);
------------------

CREATE PROCEDURE example(int) -- ошибка.
AS $$
	SELECT $1;
$$ LANGUAGE sql;

------------------------------------------------------
Практика
1. В таблице authors имена, фамилии и отчества авторов
по смыслу должны быть уникальны, но это условие никак не 
проверяется. Напишите процедуру, удаляющую возможные 
дубликаты авторов.
2. Чтобы необходимость в подобной процедуре не возникала, 
создайте ограничение целостности, которое не позволит 
появляться дубликатам в будущем;
------------------------------------------------------
DROP TABLE IF EXISTS author; 

CREATE TABLE IF NOT EXISTS author(
	id serial PRIMARY KEY, 
	first_name varchar,
	last_name varchar,
	middle_name varchar);

INSERT INTO author(last_name,first_name,middle_name)
VALUES 	('Пушкин','Александр','Сергеевич'),
		('Пушкин','Александр','Сергеевич'),
		('Пушкин','Александр','Сергеевич'),
		('Толстой','Лев','Николаевич'),
		('Толстой','Лев','Николаевич'),
		('Толстой','Лев','Николаевич'),
		('Достоевский','Фёдор','Михайлович'),
		('Достоевский','Фёдор','Михайлович'),
		('Гоголь','Николай','Васильевич');

SELECT * FROM author;

CREATE OR REPLACE PROCEDURE deldup()
AS $$
	DELETE FROM author au
	WHERE au.id IN (SELECT res1.id
				 FROM (SELECT 	id,
							last_name,
							row_number() OVER (PARTITION BY last_name, first_name, middle_name) AS rn
					  FROM author) AS res1
				 WHERE res1.rn > 1);
$$ LANGUAGE SQL;

-- оконная функция окно по имя фам отчество row_number по id, фильтр где номер_строки > 1;  
	

CALL deldup();

SELECT * FROM author;

----------------------------------------------
-- ограничение целостности
CREATE UNIQUE INDEX author_full_name_unique_idx
ON author (first_name,last_name, coalesce(middle_name,''));

DROP INDEX author_full_name_unique_idx;

INSERT INTO author(last_name,first_name)
VALUES 	('Твен','Марк');

SELECT * FROM author;

INSERT INTO author(last_name,first_name)
VALUES 	('Твен','Марк');

/******************************/
--Нормализация
        SELECT 1/max(abs(a))
        FROM samples






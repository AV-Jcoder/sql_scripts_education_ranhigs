
/**
 * DEV-1.08 Функции.
 * 
 * 
 * Основная цель появления функций в программировании вообще — 
упростить решаемую задачу за счет ее декомпозиции на более мелкие 
подзадачи. Упрощение достигается за счет того, что о функции можно 
думать, абстрагировавшись от «большой» задачи. Для этого функция 
определяет четкий интерфейс с внешним миром (параметры и 
возвращаемое значение), ну имя как бы тоже.
 * 
 * Темы
	1. Функции и их особенности в базах данных;
	2. Параметры и возвращаемое значение;
	3. Способы передачи параметров при вызове;
	4. Категории изменчивости и оптимизация;
 * 
 */

				/**** 1. Функции и их особенности в базах данных. ****/



/*******************************************************************************************************************/
/*******************************************/
/**** Создадим функцию без параметров. *****/
/*******************************************/

CREATE OR REPLACE FUNCTION hello_world() -- hellow_world это имя функции, внутри (параметры) параметры, которых нет.
RETURNS TEXT  -- тип возвращаемого значения
AS 
$Тут_был_я$ -- $$ это типо кавычки, для удобства.
SELECT 'Ты:''Hello, World!''' ||' '|| 'Мир:''Тебе тоже привет!'''; -- тело функции	  
$Тут_был_я$ LANGUAGE SQL; -- тип языка на котором функция написана. 
-- Тип языка это код только между $$ и $$.
-- Для другого языка код между $$ и $$ конечно может отличаться, но
-- все остальное остаётся одинаковым для всех языков. 
-- Всё что между $$ и $$ интерпритатор считает строковой константой.
/********************************************************************/

/**** Вызов функции *************/
SELECT hello_world();/***********/ 
/********************************/

/**** Пример двух разных функций (образец не для запуска)*************************/
hello(TEXT, integer); -- в сигнатуру функции входит ИМЯ функции			/******/
hello(integer, TEXT); -- количество и тип IN ПАРАМЕТРОВ, а так же их порядок.	/******/
-- в сигнатуру не входят OUT ПАРАМЕТРЫ.
/*********************************************************************************/

/**** Варианты написания кавычек ********************************************/
SELECT ' Ты: ''Hello, World!'' '; -- экранирование кавычек

SELECT $$ Ты: 'Hello, World!' $$; -- без экранирования кавычек

SELECT $func$ SELECT $$Ты: 'Hello, World!'$$ $func$; -- со вложеными $$
/****************************************************************************/

/***** Тело функции может состоять из нескольких операторов **************************/
CREATE OR REPLACE FUNCTION hello_world()
RETURNS text 
AS $func$ 
SELECT 'Ты:''Hello, World!''';	 -- тело
SELECT 'Мир:''Тебе тоже привет!'''; -- функции	  
$func$ LANGUAGE SQL; 
-- но в таком случае вернется первая строка в последнем операторе, т.е. ответ Мира.
/*************************************************************************************/

/**** Вызов функции *************/
SELECT hello_world();/***********/ 
/********************************/

/**** Удаление функции ******************/
DROP FUNCTION IF EXISTS hello_world;/****/
/****************************************/




/********************************************/
/**** Запрещеные команды внутри функций******/
/********************************************/
CREATE OR REPLACE FUNCTION do_commit()
RETURNS void
AS $func$
COMMIT;
$func$ LANGUAGE SQL;
-- запрещено использовать команды управления танзакциями
-- BEGIN, COMMIT, ROLLBACK. так как сама функция запускается внутри транзакции,
-- и если в функции будет оператор ROLLBACK, то неясно что с этим делать делать. 
-- запрещены служебные команды
-- VACUUM, CRATE INDEX.
-- Транзакциями можно управлять в процедурах, но не в функциях.
/********************************************/

/**** Проверка функции***********************/
SELECT do_commit();
/********************************************/

/**** Удаление функции ******************/
DROP FUNCTION IF EXISTS do_commit;/******/
/****************************************/
/*******************************************************************************************************************/


				



			/**** 2. Параметры и возвращаемое значение.  ****/



/*******************************************************************************************************************/
/**** Функции с входными параметрами ********/
/********************************************/

CREATE OR REPLACE FUNCTION hello(name text) -- name text это формальный параметр
RETURNS TEXT AS $func$
SELECT 'Hello, ' || name || '!';
$func$ LANGUAGE SQL;
-- name можно использовать в теле функции.
/********************************************/

/**** Проверка функции***********************/
SELECT hello('Lubov');			/*********/
-- литерал 'Lubov' является		/*********/
-- фактическим параметром		/*********/
/********************************************/

/**** Удаление функции ******************/
DROP FUNCTION IF EXISTS hello(text);/****/
/****************************************/




/******************************************************************************************/
/**** Создадим функцию с параметром, но без имени *****************************************/
/******************************************************************************************/
CREATE OR REPLACE FUNCTION hello(text) -- text это формальный параметр, только без имени
RETURNS text AS $func$
SELECT 'Hello, ' || $1 || '!';
$func$ LANGUAGE SQL;
-- если не указано умя функции, то мы обязаны обращатся к ней 
-- по порядковому номеру, что не всегда удобно.
/**************************************************************************************/

/**** Проверка функции***********************/
SELECT hello('Lubov');			/*********/
/********************************************/

/**** Удаление функции ******************/
DROP FUNCTION IF EXISTS hello(text);/****/
/****************************************/



/******************************************************************************************/
/**** Создадим функцию, добавив еще один текстовый параметр - обращение к человеку ********/
/******************************************************************************************/
CREATE OR REPLACE FUNCTION hello(IN name text, IN title text DEFAULT 'Mr')   /*************/
RETURNS TEXT AS $func$											  /*************/
SELECT 'Hello, ' || title ||' '|| name || '!';						  /*************/
$func$ LANGUAGE SQL;											  /*************/
-- с помощью ключевого слова IN обозначается входной параметр, но его		  /*************/
-- использование не обязатлеьно. 									  /*************/
-- DEFAULT задаёт значение по умолчанию, 							  /*************/
-- если при вызове указывается только 1 параметр						  /*************/
/******************************************************************************************/

/**** Проверка функции***********************/
SELECT hello('Smith');			/*********/
/********************************************/

/**** Проверка функции***********************/
SELECT hello('Lubov','Mis');		/*********/
/********************************************/

/**** Проверка функции**************************************/
SELECT hello(title =>'Mis', name =>'Lubov');		/*********/
SELECT hello(name => 'Smith');				/*********/
-- если формальным параметрам даны имена 		/*********/
-- то эти  имена можно использовтаь при 		/*********/
-- указании фактических параметров.			/*********/
-- а не как обычно, позиционным способом.		/*********/
-- Такой способ удобен, если порядок 			/*********/
-- параметров неочевиден, или их много,			/*********/
-- а нам нужно указать только один из них,		/*********/
-- а остальный инициализируюся по дефолту		/*********/
/***********************************************************/

/**** Проверка функции**************************************/
SELECT hello('Lubov', title => 'Mis');			/*********/
-- так же можно совмещать 					/*********/
-- позиционную передачу параметров				/*********/
-- с обращением к параметру по имени.			/*********/
-- нумерованный аргумент не может следовать 		/*********/
-- за именованным аргументом.					/*********/
/***********************************************************/

/**** Удаление функции ***********************/
DROP FUNCTION IF EXISTS hello(TEXT,TEXT);/****/
/*********************************************/





					/**** 3. Способы передачи параметров при вызове. *****/




/***********************************************************************************************************/
-- Входные значения определяются параметрами с режимом IN и INOUT								/**/
-- Выходное значение определяется либо предложением RETURNS, либо параметрами с режимом INOUT и OUT		/**/
-- если одновременно указаны обе формы, они должны быть согласованы								/**/
/***********************************************************************************************************/



/**** Создадим функцию с выходным параметром *******************/
CREATE OR REPLACE FUNCTION hello (IN name TEXT, OUT text) 
AS $func$
	SELECT 'Hello, ' || name || '!';
$func$ LANGUAGE SQL;
-- OUT выходной параметр, поэтому имя можно
-- и не указывать 
/****************************************************************/

/**** Проверка функции***********************/
SELECT hello('Smith');			/*********/
/********************************************/

/**** Удаление функции ***************************/
DROP FUNCTION IF EXISTS hello(TEXT); 		/****/
-- дропаем без указания OUT параметров		/****/
/*************************************************/



/**** Создаём функцию с указанием и OUT параметра и RETURNS параметра ************/
CREATE OR REPLACE FUNCTION hello (IN name TEXT, OUT text) 
RETURNS text
AS $func$
	SELECT 'Hello, ' || name || '!';
$func$ LANGUAGE SQL;
-- Оператор RETURN должен возвращать то же значение что и OUT 
/**********************************************************************************/

/**** Проверка функции***********************/
SELECT hello('Smith');			/*********/
/********************************************/

/**** Удаление функции ***************************/
DROP FUNCTION IF EXISTS hello(TEXT); 		/****/
-- дропаем без указания OUT параметров		/****/
/*************************************************/



/**** Создадим функцию с INOUT параметром ***********************/
CREATE OR REPLACE FUNCTION hello (INOUT name TEXT) 
AS $func$
	SELECT 'Hello, ' || name || '!';
$func$ LANGUAGE SQL;
-- (INOUT name text) - это эквавалент (IN name TEXT, OUT TEXT)
-- INOUT name не означает, что
-- мы вернём значение переменной name после завершения функции.
-- входное значение name никак не изменяется, мы можем даже указать 
-- вместо переменной константу.
/****************************************************************/

/**** Проверка функции***********************/
SELECT hello('Smith');			/*********/
/********************************************/

/**** Удаление функции **********************/
DROP FUNCTION IF EXISTS hello(TEXT);	/****/
/********************************************/



/**** Создадим функцию с несколькими выходными параметрами ******************************/
CREATE OR REPLACE FUNCTION hello (IN name TEXT, OUT greeting TEXT, OUT clock timetz, OUT nomer NUMERIC)
AS  $func$
SELECT 'Hello, ' || name || '!', current_time, random()::NUMERIC;
$func$ LANGUAGE SQL VOLATILE;
/****************************************************************************************/

/**** Проверка функции***********************/
SELECT hello('Alexey');			/*********/
-- функция действительно вернула	/*********/
-- 3 значения, строку, дату, число /*********/
-- помимо этого результат 		/*********/
-- вернулся в круглых			/*********/
-- скобках это означает ЗАПИСЬ	/*********/
/********************************************/

/**** Удаление функции **********************/
DROP FUNCTION IF EXISTS hello(TEXT);	/****/
-- указываем функцию 				/****/
-- без выходных параметров			/****/
/********************************************/
/*************************************************************************************************************************/




					/**** 4. Категории изменчивости.  ****/




/*************************************************************************************************************************/
VOLATILE возвращаемое значение может произвольно меняться при одинаковых значениях входных параметров
используется по умолчанию;(UPDATE,DELETE,INSERT);

STABLE значение не меняется в пределах одного оператора SQL функция не может менять состояние базы данных;
например в рамках одной транзакции в операторе SELECT если мы подаём одинаковые значения параметров в 
функцию, то должны получить и одинаковый результат.(SELECT ONLY);

IMMUTABLE значение не меняется, функция детерминирована, функция не может менять состояние базы данных;
функция всегда возращает однои то же значения, независимо от транзакции и оператора в котором она применялась.
SELECT (2*2);

если функция что-то изменяет в базе данных, то это VOLATILE 100%.

если функция ничего не изменяет в базе данных, то это повод поменять ей категорию изменчивости по умолчанию.
Эта функция должна быть либо STABLE либо IMMUTABLE.
Если мы читаем с базы данных, то это  STABLE, если мы ничего не читаем с базы то это IMMUTABLE.

Например функция которая умножает 2 числа 100% IMMUTABLE.
Например функция делает SELECT из таблицы и возвращает результат это STABLE.
-- препод из ПостгресПро сказал что на READ COMMITED делается снимок данных на начало оператора, поэтому
-- в рамках одного оператора мы командой селект должны читать одинаковые данные. 
-- Поэтому смело ставить STABLE.
-- это нужно проверить.;
/*************************************************************************************************************************/

				



					/**** 4.1 Категории изменчивости и изоляция *****/




/* 
 * В целом использвание функции внутри запросов не нарушает установленный уровень 
 * изоляции транзакции. Но есть два момента о которых полезно знать:
 * 
 * 
 * 
 * 
 * 1)  Во первых функции с изменчивостью VOLATILE на уровне изоляции READ COMMITED 
 * приводят к рассогласованию данных внутри одного запроса.
 * Функция VOLATILE видит изменения в бд, котороые произошли после завершения других транзакций.
 * Всё бы ничего но, это не должно происходить внутри одного оператора SELECT, прямо во время его выполнения.
 * 
 * 
 * 
 * 
 */ 
/**** Создадим таблицу и функцию, возвращающую число строк в таблице *********************/
DROP TABLE IF EXISTS table1;
DROP FUNCTION get_count(); 

/**** Таблица ****/
CREATE TABLE IF NOT EXISTS table1(
	id int
);

/**** Функция ****/
CREATE OR REPLACE FUNCTION get_count() 
RETURNS bigint AS $$
	SELECT count(id) FROM table1; -- читаем количество строк в таблице
$$ VOLATILE LANGUAGE SQL; 
-- указываем ей категорию волатайл явно,
-- хз почему она же только читает???? Тут должно было быть STABLE!!!!
/******************************************/

/* 
 * Теперь вызовим её 2 раза но с задержкой,
 * а в параллелном сеансе, во время задержки вставим строку.
 * 
 */

START TRANSACTION ISOLATION LEVEL READ COMMITTED; -- рид комитед стоит по умолчанию.

SELECT   (SELECT count(id) 
		FROM table1) AS "Через запрос", -- прямое обращение к таблице table1
		get_count() AS "Через функцию", -- обращение к таблице через функцию
		pg_sleep(1)
FROM generate_series(1,4);
-- В рамках одного запроса обращение по одному адресу должно вернуть одинаковое значение
-- Тут это не соблюдается, происходит рассогласование в рамках одного запроса. 

/**** В параллельном сеансе вставляем строку ***********/
/**************/ INSERT INTO table1 values(1); /*******/
/*******************************************************/
COMMIT;

-- тут выше происходит аномалия чтения.
-- вложенный селект не видит добавленныую строку, а
-- функция get_count() видит её, из за её пометки VOLATILE!
-- Иными словами какие-то части запроса видят зафиксированные 
-- изменения пока сам запрос ещё выполняется, видно промежуточные результаты.
/******************************************************/


При изменчивости STABLE или IMMUTABLE или более строгих уровней изоляции транзакий такой АНОМАЛИИ с функцией не происходит;
Мы могли бы поставить REPEATABLE READ, где снимок создаётся в момент выполнения первого оператора транзакции;
и далее пока транзакция не закончится все операторы видят одинаковое состояние.;


/**** Сделаем проверку задав категорию изменчивости STABLE ****/
ALTER FUNCTION get_count() STABLE;

/**** Очистим таблицу ****/
TRUNCATE table1; 

/**** Открываем тразакцию, но это не обязательно ****/
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;

/**** Запускаем запрос с функцией внутри ****/
SELECT   (SELECT count(id) 
		FROM table1) AS "Через запрос", -- прямое обращение к таблице table1
		get_count() AS "Через функцию", -- обращение к таблице через функцию
		pg_sleep(1)
FROM generate_series(1,4);

/**** В параллельном сеансе вставляем строку ***********/
/**************/ INSERT INTO table1 values(1);  /*******/
/*******************************************************/
COMMIT;
ROLLBACK;
/*******************************************************/



/**** Сделаем проверку задав категорию изменчивости VOLATILE ****/
/**** А уровень изоляции REPEATABLE READ ************************/
ALTER FUNCTION get_count() VOLATILE;

/**** Очистим таблицу ****/
TRUNCATE table1; 

/**** Открываем тразакцию ****/
START TRANSACTION ISOLATION LEVEL REPEATABLE READ;

/**** Запускаем запрос с функцией внутри ****/
SELECT   (SELECT count(id) 
		FROM table1) AS "Через запрос", -- прямое обращение к таблице table1
		get_count() AS "Через функцию", -- обращение к таблице через функцию
		pg_sleep(1)
FROM generate_series(1,4);

/**** В параллельном сеансе вставляем строку ***********/
/**************/ INSERT INTO table1 values(1);  /*******/
/*******************************************************/
COMMIT; -- измененения, сделанные в параллельной сессии 
ROLLBACK; -- мы увидим только после завершения транзакции.
/*******************************************************/


/**
 * 
 * 
 * 
 * 2) Второй момент связан с видимостью изменений, сделанных собственной транзакцией.
 * 
 * 	 Функциии с изменчивостью VOLATILE видят все изменения, в том числе сделанные 
 * 	 текущим, еще не завершенным оператором SQL.  
 * 
 * 
 */

/**** Сделаем функцию VOLATILE *******/
ALTER FUNCTION get_count() VOLATILE;

/**** Очистка таблицы ****/
TRUNCATE table1;

/**** Вставка в таблицу ****/
INSERT INTO table1 	SELECT get_count()
	   			FROM pg_catalog.generate_series(1, 5); 

/**** Проверка ****/
SELECT * FROM table1;

/**
 * Проблема в том, что функция видит то, что не должна в рамках одного оператора.
 * Она видит новые записи. Всё из-за функции с категорией изменчивости VOLATILE. 
 * Никто не должен видеть промежуточные результаты работы одного оператора, даже сам оператор не должен
 * видеть свои промежуточные результаты работы. Это аномалия.
 * Это верно для всех уровней изоляции.
 */

/**** Очистка таблицы ****/
TRUNCATE table1;

/**** Открываем тразакцию ****/
START TRANSACTION ISOLATION LEVEL REPEATABLE READ;

/**** Вставка в таблицу ****/
INSERT INTO table1 	SELECT get_count()
	   			FROM pg_catalog.generate_series(1, 5);

/**** Проверка ****/
SELECT * FROM table1;

 /**** Закрываем транзакцию ****/ 
COMMIT;
ROLLBACK;

/********************* Пробуем на сериалайзабл **************/

/**** Очистка таблицы ****/
TRUNCATE table1;

/**** Открываем тразакцию ****/
START TRANSACTION ISOLATION LEVEL SERIALIZABLE;

/**** Вставка в таблицу ****/
INSERT INTO table1 	SELECT get_count()
	   			FROM pg_catalog.generate_series(1, 5); 

/**** Проверка ****/
SELECT * FROM table1;

 /**** Закрываем транзакцию ****/ 
COMMIT;
ROLLBACK;
-- та же самая аномалия, функция видит частичный результат работы команды INSERT.
-- В рамках одного оператора функция видит 
-- изменение в базе данных, а этого быть не должно, могут наступить любые последствия.
/******************************************************************/

/**
 * Функции с изменчивостью STABLE или IMMUTABLE
 * видят изменения только 
 * уже завершенных оперторов.
 * 
 */

/**** Изменим категорию изменчивости функции ****/
ALTER FUNCTION get_count() STABLE;

/**** Очистка таблицы  ****/
TRUNCATE table1;

/**** Вставка в таблицу ****/
INSERT INTO table1  SELECT get_count()
				FROM generate_series(1,5);

/**** Проверка ****/
SELECT * FROM table1;

/**
 * Всё круто, аномалии больше нет. Категория изменчивости STABLE не даёт функции читать
 * промежуточные результаты работы опреатора INSERT. 
 * 
 */





				/**** 4.2 Категория изменчивости и оптимизация запросов. *****/





/**
 * Категория изменчивости влияет еще и на ОПТИМИЗАЦИЮ и на РЕЗУЛЬТАТ!
 * 
 * Благодаря дополнительной информации о поведении функции, 
 * которую дает указание категории изменчивости,
 * оптимизатор может сэкономить на вызовах функции. 
 */

/**** Создадим функцию возвращающую случайное число *********/
CREATE OR REPLACE FUNCTION get_random()
RETURNS float AS $$
	SELECT random();
$$ VOLATILE LANGUAGE SQL;

/**** Проверим план выполнения следующего запроса ****/
EXPLAIN (costs off) 
SELECT * 
FROM generate_series(1,10)
WHERE get_random() > 0.5;

/**** Попытаемся угадать, сколько строк вернёт запрос ****/
SELECT * 
FROM generate_series(1,10)
WHERE get_random() > 0.5;

/**** А тепрь присвоим категорию изменчивости STABLE нашей функции ****/
ALTER FUNCTION get_random() STABLE;
ALTER FUNCTION get_random() VOLATILE;
ALTER FUNCTION get_random() IMMUTABLE;

/**** Проверим план выполнения следующего запроса ****/
EXPLAIN (costs off) 
SELECT * 
FROM generate_series(1,10)
WHERE get_random() > 0.5;
-- теперь планировщик думает, что функция в рамках 
-- одного оператора SELECT будет стабильно 
-- возвращать один и тот же результат.
-- т.е. все 10 раз функция вернёт одинаковый результат,
-- но только в одном запросе, в дргуом запросе функция вернёт другой
-- результат, но тоже все 10 раз одинаковый.
--  One-Time Filter: (get_random() > '0.5'::double precision)
-- если возвращает истину, то будет выполнен  ->  Function Scan on generate_series
-- если One-Time Filter возвращает лож, то ни одной строки не будет выведено.
/******************************************************/

/**** Изменим категорию на IMMUTABLE ****/
ALTER FUNCTION get_random() IMMUTABLE;

/**** Заглянем в планировщик ****/
EXPLAIN (costs off) 
SELECT * 
FROM generate_series(1,10)
WHERE get_random() > 0.5;
-- СУБД вычисляет функцию еще на этапе планирования, и исходя из 
-- вычесленного результата, понимает, нужно-ли ей дальше делать 
-- какие либо запросы.
-- Если на этапе планирования функция вернула false, то на 
-- этапе выполнения уже ничего не делается.
-- Планировщик считает, что функция всегда 
-- возвращает одинаковый результат.

/**
 * Итак мы видим, что категория изменчивости с одной стороны влияет на оптимизацию,
 * например наша функция в рамках запроса может выполняться не каждый раз,
 * а всего лишь один раз, для категорий STABLE и IMMUTABLE. И это хорошо,  т.к.
 * запрос будет работать быстрее, но вместе с этим стоит учитывать, что и результат
 * может быть разный.
 * 
 * Если при VOLATILE происходит 10 вызовов и примерно в 50% случаев срабатывает фильтр, то
 * в двух других категориях изменчивости функция запускается только один раз
 * и выводится на дисплей либо всё либо ничего.
 * 
 * СУБД PostgresQL никак не контролирует разработчика, не проверяет, можно-ли это
 * делать или нельзя.
 * 
 * Ответственность за выбор категории изменчивости лежит наразработчике.
 * 
 */



			/**** 4.3 Подстановка тела функции в SQL запрос. ****/


/**
 * В некоторых очень простых случаях
 * тело функции на языке SQL может быть подставлено 
 * прямо в основной SQL-оператор на этапе рабора запроса.
 * В этом случае время на вызов функции не тратится.
 * 
 * Упрощенно требуется выполнение следующих условий:
 * 	- тело функции состоит из одного оператора SELECT
 * 	- нет обращений к таблицам, отсутствуют подзапросы, группировки итд
 * 	- возвращаемое значение должно быть одно
 * 	- вызываемые функции не должны противоречить указанной категории изменчивости
 * 
 * Один из примеров это фнкция get_random() с категорией изменчивости VOLATILE
 * 
 * Посмотрим еще раз 
 * 
 */

ALTER FUNCTION get_random() VOLATILE;

EXPLAIN (costs off)
SELECT *
FROM generate_series(1,5)
WHERE get_random() > 0.5;

-- Filter: (random() > '0.5'::double precision)
-- подстановка random() вместо get_random()
-- решение СУБД.
/*********************************************************/



		Практика;
	
	
/*********************************************************/
	
	/** 
11
Практика
1. Создайте функцию author_name для формирования имени 
автора. Функция принимает три параметра (фамилия, имя, 
отчество) и возвращает строку с фамилией и инициалами.
 
Используйте эту функцию в представлении authors_v.
2. Создайте функцию book_name для формирования названия 
книги.
Функция принимает два параметра (идентификатор книги
и заголовок) и возвращает строку, составленную из 
заголовка и списка авторов в порядке seq_num. Имя каждого 
автора формируется функций author_name.
 
Используйте эту функцию в представлении catalog_v.
Проверьте изменения в приложении.
	 */

	
	/****   1   *******/
DROP FUNCTION author_name(TEXT,TEXT, TEXT);	
	
CREATE OR REPLACE FUNCTION author_name(last_name TEXT, first_name TEXT, fathers_name TEXT)
RETURNS TEXT AS 
$Hello$
DECLARE 
fu_name TEXT = substring(first_name for 1);
fu_fath_name TEXT = substring(fathers_name for 1);
fu_result text;
BEGIN	
	fu_result = last_name||' '||fu_name||' '||fu_fath_name;
RETURN fu_result;
END; 
$Hello$ LANGUAGE plpgSQL;

SELECT author_name('Tolstoj', 'Lev', 'Nikolaevich');












